# A2UI: Agent-to-User Interface

A2UI is an open-source protocol and library ecosystem for agent-generated user interfaces. It allows AI agents to dynamically create rich, interactive UIs that render natively across web, mobile, and desktop platforms without executing arbitrary code. Agents send declarative JSON messages describing UI structure and data, while client applications render these messages using their own native component libraries (Angular, Flutter, Lit, React, etc.). This approach ensures agent-generated UIs are safe like data but expressive like code.

The protocol separates UI structure from application state through a clean data binding model. Agents stream JSON messages over any transport (A2A Protocol, Server-Sent Events, WebSockets), enabling progressive rendering and dynamic updates. The core philosophy prioritizes security (no code execution), LLM-friendliness (flat component lists with ID references), and framework-agnostic portability (one JSON payload works everywhere). A2UI is particularly valuable for multi-agent systems where remote agents need to present interfaces without direct DOM access, dynamic data collection forms, adaptive workflows, and conversational AI applications that benefit from rich UI beyond text.

## Core Protocol Implementation

This section details the fundamental mechanics of the A2UI protocol. A compliant renderer must implement these systems to successfully parse the server stream, manage state, and handle user interactions.

### Message Processing & State Management
- **JSONL Stream Parsing**: Implement a parser that can read a streaming response line by line, decoding each line as a distinct JSON object.
- **Message Dispatcher**: Create a dispatcher to identify the message type (`beginRendering`, `surfaceUpdate`, `dataModelUpdate`, `deleteSurface`) and route it to the correct handler.
- **Surface Management**:
  - Implement a data structure to manage multiple UI surfaces, each keyed by its `surfaceId`.
  - Handle `surfaceUpdate`: Add or update components in the specified surface's component buffer.
  - Handle `deleteSurface`: Remove the specified surface and all its associated data and components.
- **Component Buffering (Adjacency List)**:
  - For each surface, maintain a component buffer (e.g., a `Map<String, Component>`) to store all component definitions by their `id`.
  - Be able to reconstruct the UI tree at render time by resolving `id` references in container components (`children.explicitList`, `child`, `contentChild`, etc.).
- **Data Model Store**:
  - For each surface, maintain a separate data model store (e.g., a JSON object or a `Map<String, any>`)
  - Handle `dataModelUpdate`: Update the data model at the specified `path`. The `contents` will be in an adjacency list format (e.g., `[{ "key": "name", "valueString": "Bob" }]`).

### Rendering Logic
- **Progressive Rendering Control**:
  - Buffer all incoming `surfaceUpdate` and `dataModelUpdate` messages without rendering immediately.
  - Handle `beginRendering`: This message acts as the explicit signal to perform the initial render of a surface and set the root component ID.
    - Start rendering from the specified `root` component ID.
    - If a `catalogId` is provided, ensure the corresponding component catalog is used (defaulting to the standard catalog if omitted).
    - Apply any global `styles` (e.g., `font`, `primaryColor`) provided in this message.
- **Data Binding Resolution**:
  - Implement a resolver for `BoundValue` objects found in component properties.
  - If only a `literal*` value is present (`literalString`, `literalNumber`, etc.), use it directly.
  - If only a `path` is present, resolve it against the surface's data model.
  - If both `path` and `literal*` are present, first update the data model at `path` with the literal value, then bind the component property to that `path`.
- **Dynamic List Rendering**:
  - For containers with a `children.template`, iterate over the data list found at `template.dataBinding` (which resolves to a list in the data model).
  - For each item in the data list, render the component specified by `template.componentId`, making the item's data available for relative data binding within the template.

## Creating A2UI Messages from Agents

### Python: Generate A2UI JSON with LLM

Generate A2UI messages from an LLM-powered agent using structured prompts and schema validation.

```python
import json
import jsonschema
from google.adk.agents.llm_agent import LlmAgent
from google.adk.models.lite_llm import LiteLlm

# Define A2UI schema for validation
A2UI_SCHEMA = {
    "type": "array",
    "items": {
        "oneOf": [
            {"type": "object", "properties": {"createSurface": {"type": "object"}}},
            {"type": "object", "properties": {"updateComponents": {"type": "object"}}},
            {"type": "object", "properties": {"updateDataModel": {"type": "object"}}},
            {"type": "object", "properties": {"deleteSurface": {"type": "object"}}}
        ]
    }
}

# Build agent with A2UI generation instructions
agent = LlmAgent(
    model=LiteLlm(model="gemini/gemini-2.5-flash"),
    name="restaurant_agent",
    instruction="""
    Generate A2UI messages as a JSON list. Your response must have two parts
    separated by '---a2ui_JSON---': conversational text, then the JSON array.
    Follow the A2UI JSON schema for all messages.
    """,
    tools=[get_restaurants]
)

# Parse and validate LLM output
final_response = "Here are restaurants---a2ui_JSON---[{\"createSurface\": {...}}]"
text_part, json_string = final_response.split("---a2ui_JSON---", 1)
json_cleaned = json_string.strip().lstrip("```json").rstrip("```").strip()
parsed_json = json.loads(json_cleaned)

# Validate against schema
jsonschema.validate(instance=parsed_json, schema=A2UI_SCHEMA)
# Output: Valid A2UI messages ready to stream to client

# Stream to client
for message in parsed_json:
    yield json.dumps(message) + "\n"  # JSONL format
```

## Client-Side Integration

### Angular: Render A2UI Components

Integrate A2UI rendering into Angular applications using the dynamic component system.

```typescript
import { Component, input } from '@angular/core';
import { Types } from '@a2ui/lit/0.8';
import { DynamicComponent } from '../rendering/dynamic-component';
import { Renderer } from '../rendering/renderer';

@Component({
  selector: 'a2ui-button',
  imports: [Renderer],
  template: `
    <button
      [class]="theme.components.Button"
      [style]="theme.additionalStyles?.Button"
      (click)="handleClick()"
    >
      <ng-container
        a2ui-renderer
        [surfaceId]="surfaceId()!"
        [component]="component().properties.child"
      />
    </button>
  `,
  styles: `
    :host {
      display: block;
      flex: var(--weight);
      min-height: 0;
    }
  `,
})
export class Button extends DynamicComponent<Types.ButtonNode> {
  readonly action = input.required<Types.Action | null>();

  protected handleClick() {
    const action = this.action();
    if (action) {
      super.sendAction(action);
    }
  }
}
```

### Web (Lit): Install and Configure

Installs the necessary npm packages for A2UI web client using Lit and demonstrates how to connect to an agent, stream responses, and process messages using MessageProcessor.

```bash
npm install @a2ui/web-lib lit @lit-labs/signals
```

```typescript
import { MessageProcessor } from '@a2ui/web-lib';
import { html, LitElement } from 'lit';

class A2UIApp extends LitElement {
  private messageProcessor = new MessageProcessor();

  async connectToAgent(agentUrl: string) {
    const response = await fetch(agentUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ message: 'Find restaurants near me' })
    });

    const reader = response.body!.getReader();
    const decoder = new TextDecoder();

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const lines = decoder.decode(value).split('\n');
      for (const line of lines) {
        if (line.trim()) {
          const message = JSON.parse(line);
          this.messageProcessor.processMessage(message);
        }
      }
    }
  }

  render() {
    return html`<a2ui-surface surfaceId="main"></a2ui-surface>`;
  }
}
```
